<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aca.github.io</title>
  <subtitle>undefined</subtitle>
  <link href="https://aca.github.io/feed.xml" rel="self"/>
  <link href="https://aca.github.io"/>
  <updated>2023-04-30T00:00:00Z</updated>
  <id>https://aca.github.io</id>
  <author>
    <name>aca</name>
    <email>acadx0@gmail.com</email>
  </author>
  
  <entry>
    <title>undefined</title>
    <link href="https://aca.github.io/posts/introduction-to-blog/"/>
    <updated>2023-04-28T00:00:00Z</updated>
    <id>https://aca.github.io/posts/introduction-to-blog/</id>
    <content type="html">&lt;section&gt;&lt;p&gt;TODO&lt;/p&gt;
&lt;/section&gt;</content>
  </entry>
  
  <entry>
    <title>undefined</title>
    <link href="https://aca.github.io/posts/zettelkasten/"/>
    <updated>2023-04-30T00:00:00Z</updated>
    <id>https://aca.github.io/posts/zettelkasten/</id>
    <content type="html">&lt;section&gt;&lt;p&gt;Zettelkasten is the way to organize notes.
While idea itself is extremely simple, details of how the system should work is not clear.
Right now, I’m just keep writing things in markdown, editing in vim, searching with ripgrep + fzf.&lt;/p&gt;
&lt;p&gt;System I want is&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;well-defined, minimal protocols.&lt;/li&gt;
&lt;li&gt;Requires minimal metadata or configurations for it.&lt;/li&gt;
&lt;li&gt;future-proof, tools may change but idea should remain.&lt;/li&gt;
&lt;li&gt;Scalability, system should work as usual even if you join whole zettels of thousands of people.&lt;/li&gt;
&lt;li&gt;Hackable by all people. Which means it should be written in general purposed, easy language and have simple architecture.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;Ref&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://giscalablethub.com/srid/neuron&quot;&gt;neuron&lt;/a&gt;(dead)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;integration with pandoc, focused on CLI, static site generator.&lt;/li&gt;
&lt;li&gt;LSP with &lt;a href=&quot;https://github.com/aca/neuron-language-server&quot;&gt;aca/neuron-language-server&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;obsidian&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fine mobile support&lt;/li&gt;
&lt;li&gt;excalidraw integration&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=34066824&quot;&gt;obsidian canvas&lt;/a&gt;?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git integration&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git annex&lt;/li&gt;
&lt;li&gt;git as a database approach &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hand writing&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;workflow&lt;/li&gt;
&lt;li&gt;e-ink devices&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://roamresearch.com/&quot;&gt;Roam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.orgroam.com/&quot;&gt;Org-Roam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Secrets&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://news.ycombinator.com/item?id=32066513&quot;&gt;Denote&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extremely well documented protocol.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;</content>
  </entry>
  
  <entry>
    <title>undefined</title>
    <link href="https://aca.github.io/posts/go-channel-quiz/"/>
    <updated>2023-04-30T00:00:00Z</updated>
    <id>https://aca.github.io/posts/go-channel-quiz/</id>
    <content type="html">&lt;section&gt;&lt;p&gt;Channel in go always amazes me when solving concurrency issues. Here’s an example.&lt;/p&gt;
&lt;p&gt;When writing &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;language server&lt;/a&gt;, I had to generate a diagnostic report based on document changes with textDocument/diagnostic&lt;label for=&quot;sd-less-than-a-href&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sd-less-than-a-href&quot; class=&quot;margin-toggle&quot; /&gt;&lt;span class=&quot;sidenote&quot;&gt;&lt;a href=&quot;https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_diagnostic&quot;&gt;https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_diagnostic&lt;/a&gt;&lt;/span&gt;.
As document changes on every keyboard input and diagnostic normally require heavy computation, there should be a way to throttle requests.
Throttling is quite tricky if we want to make sure that the diagnostic report is based on the last modification.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server only handles one request, put the next request in the queue.&lt;/li&gt;
&lt;li&gt;If another request comes in, the server should discard waiting request and enqueue the latest one.&lt;/li&gt;
&lt;li&gt;No lock. No polling.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here’s my answer with one unbuffered, and one buffered channel.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;log&quot;
    &quot;time&quot;
)

var (
    DiagChan    chan int = make(chan int, 1)
    DiagReqChan chan int = make(chan int)
)

func RunDiagnostic() {
    for v := range DiagChan {
        log.Println(&quot;[diag] start&quot;, v)
        defer log.Println(&quot;[diag] end&quot;, v)
        time.Sleep(time.Second)
    }
}

func HandleDiagnosticRequest() {
    for req := range DiagReqChan {
        select {
        case DiagChan &amp;#x3C;- req:
            log.Println(&quot;queued request&quot;, req)
        default:
            reqDiscarded := &amp;#x3C;-DiagChan
            log.Printf(&quot;discard %v, queued %v&quot;, reqDiscarded, req)
            DiagChan &amp;#x3C;- req
        }
    }
}

func main() {
    go RunDiagnostic()
    go HandleDiagnosticRequest()
    go func() {
        DiagReqChan &amp;#x3C;- 1
        DiagReqChan &amp;#x3C;- 2
        DiagReqChan &amp;#x3C;- 3
        DiagReqChan &amp;#x3C;- 4
        DiagReqChan &amp;#x3C;- 5
    }()
    select {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;queued request 1
queued request 2
discard 2, queued 3
discard 3, queued 4
discard 4, queued 5
[diag] start 1
[diag] end 1
[diag] start 5
[diag] end 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;</content>
  </entry>
</feed>
